/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.awt.Color;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.SwingConstants;
import java.util.Arrays;
import java.util.Random;
/**
 *
 * @author hackp
 */
public class Hello extends javax.swing.JFrame {

    //My image will keep our raw image always, and current image will change with filters
    BufferedImage myImage, currentImage;
    
    //If image uploaded to our program, it will be true
    boolean imageOk = false;
    
    //Our almost all process will be on this array. 
    int[][] blackWhiteImage;
    
    //It will keep histogram datas.
    int [] histogramArray;
    
    //We will use it for scaling histogram datas to draw panel and image.
    float rate = 1;
    /**
     * Creates new form Hello
     */
    public Hello() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        select = new javax.swing.JButton();
        imagePanel = new javax.swing.JPanel();
        label = new javax.swing.JLabel();
        reset = new javax.swing.JButton();
        blackWhite = new javax.swing.JButton();
        histogram = new javax.swing.JButton();
        otsu = new javax.swing.JButton();
        histogramPanel = new javax.swing.JPanel();
        his_min = new java.awt.Label();
        his_max = new java.awt.Label();
        sepiaButton = new javax.swing.JButton();
        negative = new javax.swing.JButton();
        stretch = new javax.swing.JButton();
        mean = new javax.swing.JButton();
        median = new javax.swing.JButton();
        gaussian = new javax.swing.JButton();
        save = new javax.swing.JButton();
        saveHistogram = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("HP Image Process");
        setResizable(false);

        select.setText("Select Image");
        select.setActionCommand("filer");
        select.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectActionPerformed(evt);
            }
        });

        imagePanel.setBorder(new javax.swing.border.MatteBorder(null));
        imagePanel.setMaximumSize(new java.awt.Dimension(253, 143));

        reset.setBackground(new java.awt.Color(102, 255, 102));
        reset.setText("RESET");
        reset.setBorderPainted(false);
        reset.setEnabled(false);
        reset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout imagePanelLayout = new javax.swing.GroupLayout(imagePanel);
        imagePanel.setLayout(imagePanelLayout);
        imagePanelLayout.setHorizontalGroup(
            imagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(imagePanelLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addGroup(imagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(label, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 475, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(reset, javax.swing.GroupLayout.Alignment.TRAILING)))
        );
        imagePanelLayout.setVerticalGroup(
            imagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(imagePanelLayout.createSequentialGroup()
                .addComponent(reset)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(label, javax.swing.GroupLayout.PREFERRED_SIZE, 210, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        label.getAccessibleContext().setAccessibleName("label");

        blackWhite.setText("Black & White");
        blackWhite.setEnabled(false);
        blackWhite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                blackWhiteActionPerformed(evt);
            }
        });

        histogram.setText("Histogram");
        histogram.setEnabled(false);
        histogram.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                histogramActionPerformed(evt);
            }
        });

        otsu.setText("Otsu");
        otsu.setEnabled(false);
        otsu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                otsuActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout histogramPanelLayout = new javax.swing.GroupLayout(histogramPanel);
        histogramPanel.setLayout(histogramPanelLayout);
        histogramPanelLayout.setHorizontalGroup(
            histogramPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(histogramPanelLayout.createSequentialGroup()
                .addGap(75, 75, 75)
                .addComponent(his_min, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 249, Short.MAX_VALUE)
                .addComponent(his_max, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(75, 75, 75))
        );
        histogramPanelLayout.setVerticalGroup(
            histogramPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(histogramPanelLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addGroup(histogramPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(his_min, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(his_max, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        sepiaButton.setEnabled(false);
        sepiaButton.setLabel("Sepia");
        sepiaButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sepiaButtonActionPerformed(evt);
            }
        });

        negative.setText("Negative");
        negative.setEnabled(false);
        negative.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                negativeActionPerformed(evt);
            }
        });

        stretch.setText("Contrast");
        stretch.setEnabled(false);
        stretch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stretchActionPerformed(evt);
            }
        });

        mean.setText("Mean");
        mean.setEnabled(false);
        mean.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                meanActionPerformed(evt);
            }
        });

        median.setText("Median");
        median.setEnabled(false);
        median.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                medianActionPerformed(evt);
            }
        });

        gaussian.setText("Gaussian");
        gaussian.setEnabled(false);
        gaussian.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gaussianActionPerformed(evt);
            }
        });

        save.setText("Save");
        save.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveActionPerformed(evt);
            }
        });

        saveHistogram.setText("Save Histogram");
        saveHistogram.setEnabled(false);
        saveHistogram.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveHistogramActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(select, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(imagePanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(blackWhite, javax.swing.GroupLayout.DEFAULT_SIZE, 134, Short.MAX_VALUE)
                            .addComponent(histogram, javax.swing.GroupLayout.DEFAULT_SIZE, 134, Short.MAX_VALUE)
                            .addComponent(mean, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(stretch, javax.swing.GroupLayout.DEFAULT_SIZE, 135, Short.MAX_VALUE)
                            .addComponent(sepiaButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(median, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(38, 38, 38)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(negative, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(otsu, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(gaussian, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(save, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(histogramPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(saveHistogram)
                        .addGap(155, 155, 155))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(histogramPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(imagePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(select, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(saveHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(9, 9, 9)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(negative, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(blackWhite, javax.swing.GroupLayout.DEFAULT_SIZE, 58, Short.MAX_VALUE)
                        .addComponent(sepiaButton, javax.swing.GroupLayout.DEFAULT_SIZE, 58, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(otsu, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(histogram, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(stretch, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(mean, javax.swing.GroupLayout.DEFAULT_SIZE, 55, Short.MAX_VALUE)
                    .addComponent(median, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(gaussian, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(save, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void selectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectActionPerformed
        // TODO add your handling code here:
        
        //Choose image file 
        JFileChooser jfc;
        jfc = new JFileChooser();
        jfc.showOpenDialog(this);
        File selFile = jfc.getSelectedFile();
        
        //File to image. If user choose non-image file, it will not respond and return. 
        try
        {
            myImage = ImageIO.read(selFile);
        }
        catch(Exception e){ System.out.println("Error"); return;}
        
        //Create black&white array with size
        blackWhiteImage = new int[myImage.getWidth()][myImage.getHeight()];
        
        //Hold current state of image
        currentImage = new BufferedImage(myImage.getWidth(), myImage.getHeight(), BufferedImage.TYPE_INT_RGB);
        currentImage = myImage;
        
        //Setting current image to panel 
        setIconImage(currentImage);
        
        //Some buttons can be enabled, and others will be enabled later.
        blackWhite.setEnabled(true);
        sepiaButton.setEnabled(true);
        negative.setEnabled(true);
        reset.setEnabled(true);
        histogram.setEnabled(false);
        stretch.setEnabled(false);
        otsu.setEnabled(false);
        mean.setEnabled(false);
        median.setEnabled(false);
        gaussian.setEnabled(false);
        saveHistogram.setEnabled(false);
       
    }//GEN-LAST:event_selectActionPerformed

    private void histogramActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_histogramActionPerformed
        // TODO add your handling code here:
        
        //Create black&white array and histogram          
        createBlackWhite();
        createHistogram();
        
        //Buttons which has dependency to histogram are enabled now.
        stretch.setEnabled(true);
        mean.setEnabled(true);
        median.setEnabled(true);
        gaussian.setEnabled(true);
        otsu.setEnabled(true);
        saveHistogram.setEnabled(true);
        
    }//GEN-LAST:event_histogramActionPerformed

    void createHistogram()
    {
        histogramArray = new int[256];
        
        //We will use it to scaling for drawing.  
        int highScore = 0;
        
        //Histogram array set to zero
        for(int counter1 = 0; counter1 < 255; counter1++) histogramArray[counter1] = 0;
        
        //We will scan all b&w array and we will collect our histogram data
        for(int counter1 = 0; counter1 < myImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < myImage.getHeight(); counter2++)
            {
                histogramArray[blackWhiteImage[counter1][counter2]]++;
                
                if(histogramArray[blackWhiteImage[counter1][counter2]] > highScore)
                      highScore = histogramArray[blackWhiteImage[counter1][counter2]];
            }
        }
        
        
        //We will set rate if our high pixel value will be upper than 200
        if(highScore > 200)
           rate = (200 / (float)highScore);
      
        // We will draw histogram
        Graphics g = histogramPanel.getGraphics();
        drawHistogramGraph(g);
    }
    
    void drawHistogramGraph(Graphics g)
    {
        //I put these labels to show start and stop values. 
        his_min.setText("0");
        his_max.setText("255");

        //Clear panel for every drawing
        g.clearRect(0, 0, histogramPanel.getWidth(), histogramPanel.getHeight());
        g.setColor(Color.red);
        
        //Every value will shown by line. 92, 348 and 210 are for panle size. They can change by size.
        for(int counter1 = 92; counter1 < 348; counter1++)
        {
            g.drawLine(counter1, 210, counter1, 210-(int)(histogramArray[counter1-92]*rate));
        }
        
    }
    
    private void blackWhiteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_blackWhiteActionPerformed
        
        //With this button, our current image will be b&w and histogram creating will be enabled.
        createBlackWhite();
        histogram.setEnabled(true);
    }//GEN-LAST:event_blackWhiteActionPerformed

    private void sepiaButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sepiaButtonActionPerformed
        // TODO add your handling code here:
        //Creating Sepia effect to image
        BufferedImage sepiaImage = new BufferedImage(currentImage.getWidth(), currentImage.getHeight(), BufferedImage.TYPE_INT_RGB);
        
            int red, green, blue; 
                float adv;
                
        //Apply sepia effect to image. I found rates from source.         
        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
                red = new Color(currentImage.getRGB(counter1, counter2)).getRed();
                green = new Color(currentImage.getRGB(counter1, counter2)).getGreen();
                blue = new Color(currentImage.getRGB(counter1, counter2)).getBlue();
                
                adv = (float)(red * 0.299) + (float)(green *0.587) + (float)(blue * 0.114);
                
                // red
                red = (int)( ( adv > 206 ) ? 255 : adv + 49 );
                // green
                green = (int)( ( adv < 14 ) ? 0 : adv - 14 );
                // blue
                blue =  (int)( ( adv < 56 ) ? 0 : adv - 56 );
                
                
                sepiaImage.setRGB(counter1, counter2, new Color(red, green, blue).getRGB());
            }
        }
        
        currentImage = sepiaImage;
        setIconImage(currentImage);    
        
    }//GEN-LAST:event_sepiaButtonActionPerformed

    private void resetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetActionPerformed
        // TODO add your handling code here:
        
        //We change the current image to raw image 
        currentImage = myImage;
        setIconImage(currentImage);
        
        //Some buttons should be unavailable.
        histogram.setEnabled(false);
        stretch.setEnabled(false);
        otsu.setEnabled(false);
        mean.setEnabled(false);
        median.setEnabled(false);
        gaussian.setEnabled(false);
    }//GEN-LAST:event_resetActionPerformed

    private void negativeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_negativeActionPerformed
        // TODO add your handling code here:
        //In this method, we are using reverse of b&w array. 
        BufferedImage negativeImage = new BufferedImage(currentImage.getWidth(), currentImage.getHeight(), BufferedImage.TYPE_INT_RGB);
        
        int red, green, blue; 
                float adv;
                
        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
                red = new Color(currentImage.getRGB(counter1, counter2)).getRed();
                green = new Color(currentImage.getRGB(counter1, counter2)).getGreen();
                blue = new Color(currentImage.getRGB(counter1, counter2)).getBlue();
                
                adv = (float)(0.11*red) + (float)(0.59*green) + (float)(0.3*blue);
                
                //Reverse of b&w array
                blackWhiteImage[counter1][counter2] = 255-(int)adv;
                
                Color cl = new Color(255-(int)adv, 255-(int)adv, 255-(int)adv);
                negativeImage.setRGB(counter1, counter2, cl.getRGB());
            }
        }
        
       
        
        currentImage = negativeImage;
        setIconImage(currentImage);
        histogram.setEnabled(true);
        
    }//GEN-LAST:event_negativeActionPerformed

    private void stretchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stretchActionPerformed
        // TODO add your handling code here:

        createBlackWhite();
        createHistogram();
        int  maxgrey=0, mingrey=0, max = 0, min =histogramArray[0];
 
        

        for(int counter1 = 0; counter1 < 256; counter1++)
        {
            //We find max and min histogram values which are different from zero
            if(histogramArray[counter1] != 0) maxgrey = counter1;
            if(mingrey == 0 && histogramArray[counter1] != 0) mingrey = counter1;


        }

        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
             
                //I applied formula to all pixels.  
                blackWhiteImage[counter1][counter2] = ( int )( ( (float)blackWhiteImage[counter1][counter2] - (float)mingrey ) * ( 255 / ( (float)maxgrey - (float)mingrey ) ) );
                
                //Sometimes we get values which are over the 0-255. I stop that with this way.
                if(blackWhiteImage[counter1][counter2] < 0)
                    blackWhiteImage[counter1][counter2] = 0;
                if(blackWhiteImage[counter1][counter2] > 255)
                    blackWhiteImage[counter1][counter2] = 255;
            }
        }

        createImageFromArray(blackWhiteImage);
    }//GEN-LAST:event_stretchActionPerformed

    private void meanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_meanActionPerformed
        // TODO add your handling code here:
        //Before the filter, I set b&w and histogram arrays. 
        createBlackWhite();
        createHistogram();
        Mean();
    }//GEN-LAST:event_meanActionPerformed

    private void medianActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_medianActionPerformed
        // TODO add your handling code here:
        //Before the filter, I set b&w and histogram arrays.
        createBlackWhite();
        createHistogram();
        Median();
    }//GEN-LAST:event_medianActionPerformed

    private void gaussianActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gaussianActionPerformed
        // TODO add your handling code here:
        //Before the filter, I set b&w and histogram arrays.
        createBlackWhite();
        createHistogram();
        Gaussian();
    }//GEN-LAST:event_gaussianActionPerformed

    private void saveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveActionPerformed
        // TODO add your handling code here:
        
        //Choose file 
        JFileChooser jfc;
        jfc = new JFileChooser();
        jfc.showOpenDialog(this);
        
        //Create image path and name from file chooser dialog
        String imageName = jfc.getCurrentDirectory() + "/"+ jfc.getSelectedFile().getName()+".jpg";
       
        //Writing the file 
        File fl = new File(imageName);
        try
        {
            ImageIO.write(currentImage, "jpg", fl);
        }
        catch(Exception e){}
        
    }//GEN-LAST:event_saveActionPerformed

    private void otsuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_otsuActionPerformed
        // TODO add your handling code here:
        //Before the filter, I set b&w and histogram arrays.
        
        createBlackWhite();
        createHistogram();
        
        int otsuValue=0;
        double fmax = -1.0;
        double m1, m2, S, sum1 = 0.0, sum2 = 0.0;
        int nTop = 0, n1 = 0, n2;
        BufferedImage otsuImage = new BufferedImage(currentImage.getWidth(), currentImage.getHeight(), BufferedImage.TYPE_INT_RGB);

        //Applying the otsu algorithm to find best treshold value
        for (int counter1 = 0; counter1 < 256; counter1++)
        {
            sum1 += (double)counter1 * (double)histogramArray[counter1];
            nTop += histogramArray[counter1];
        }

        for (int counter1 = 0; counter1 < 256; counter1++)
        {
            n1 += histogramArray[counter1];
            
            if (n1 == 0)
                continue;
            
            n2 = nTop - n1;
            
            if (n2 == 0)
                break;
            
            sum2 += (double)counter1 * (double)histogramArray[counter1];
            m1 = sum2 / n1;
            m2 = (sum1 - sum2) / n2;
            S = (double)n1 * (double)n2 * (m1 - m2) * (m1 - m2);
            
            if (S > fmax)
            {
                fmax = S;
                otsuValue = counter1;
            }
        }

        
        //Changing the current image and b&w array to binary state by otsu treshold value
        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
               
               if(blackWhiteImage[counter1][counter2] < otsuValue)
               {
                   otsuImage.setRGB(counter1, counter2, new Color(0,0,0).getRGB());
               }
               else otsuImage.setRGB(counter1, counter2, new Color(255,255,255).getRGB());
            }
        }
        
        currentImage = otsuImage;
        setIconImage(currentImage);
    }//GEN-LAST:event_otsuActionPerformed

    private void saveHistogramActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveHistogramActionPerformed
        // TODO add your handling code here:

        //Choose file directory
        JFileChooser jfc;
        jfc = new JFileChooser();
        jfc.showOpenDialog(this);

        BufferedImage histogramDraw = new BufferedImage(histogramPanel.getWidth(), histogramPanel.getHeight(), BufferedImage.TYPE_INT_RGB);
        
        //Drawing histogram to image
        Graphics g = histogramDraw.getGraphics();
        drawHistogramGraph(g);

        //Save image to directory which user choose 
        String imageName = jfc.getCurrentDirectory() + "/"+ jfc.getSelectedFile().getName()+".jpg";
        
        //File writing
        File fl = new File(imageName);
        try
        {
            ImageIO.write(histogramDraw, "jpg", fl);
        }
        catch(Exception e){}
    }//GEN-LAST:event_saveHistogramActionPerformed

    void createBlackWhite()
    {
        BufferedImage blackImage = new BufferedImage(currentImage.getWidth(), currentImage.getHeight(), BufferedImage.TYPE_INT_RGB);
        
        int red, green, blue; 
                float adv;
        
        //Creating grey values of every pixels. And save them in the b&w array. Also current image changed too.
        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
                //Getting rgb values
                red = new Color(currentImage.getRGB(counter1, counter2)).getRed();
                green = new Color(currentImage.getRGB(counter1, counter2)).getGreen();
                blue = new Color(currentImage.getRGB(counter1, counter2)).getBlue();
                //Creating grey value
                adv = (float)(0.11*red) + (float)(0.59*green) + (float)(0.3*blue);
                //Save on b&w array
                blackWhiteImage[counter1][counter2] = (int)adv;
                //Chage current image
                Color cl = new Color((int)adv, (int)adv, (int)adv);
                blackImage.setRGB(counter1, counter2, cl.getRGB());
            }
        }
        
        currentImage = blackImage;
        setIconImage(currentImage);
    }
 
    void Mean()
    {
        int[][] meanPixelArray = new int[currentImage.getWidth()][currentImage.getHeight()];
        
        //Applying mean filter to image. Mean is 3x3 matrix and they are neighbor of pixel with pixel. Average of matrix is new value of pixel. 
        for (int counter1 = 1; counter1 < currentImage.getHeight() - 1; counter1++)
        {
            for (int counter2 = 1; counter2 < currentImage.getWidth() - 1; counter2++)
            {
                meanPixelArray[counter2][counter1] = ( blackWhiteImage[counter2][ counter1 - 1] + blackWhiteImage[counter2][ counter1 + 1]
                + blackWhiteImage[counter2][ counter1]
                + blackWhiteImage[counter2 - 1][ counter1 - 1]
                + blackWhiteImage[counter2 - 1][ counter1 + 1]
                + blackWhiteImage[counter2 - 1][ counter1]
                + blackWhiteImage[counter2 + 1][ counter1 - 1]
                + blackWhiteImage[counter2 + 1][ counter1 + 1]
                + blackWhiteImage[counter2 + 1][ counter1]
                ) / 9;
            }
        }
        
         createImageFromArray(meanPixelArray);
    }
    
    void Gaussian()
    {
        int[][] gaussianPixelArray = new int[currentImage.getWidth()][currentImage.getHeight()];

        //Gaussian array is 5x5 matrix. It has own value. So it will give weight to pixels. Near pixels have more weight.
        int[][] gaussianArray =
        new int[][] {
        {1,4,7,4,1},
        {4,16,26,16,4},
        {7,26,41,26,7},
        {4,16,26,16,4},
        {1,4,7,4,1}
        };
        
        int tempSum;
        for (int counter1 = 2; counter1 < currentImage.getHeight() - 2; counter1++)
        {
            for (int counter2 = 2; counter2 < currentImage.getWidth() - 2; counter2++)
            {
                tempSum = 0;
                for (int counter3 = -2; counter3 < 3; counter3++)
                {
                    for (int counter4 = -2;  counter4 < 3;  counter4++)
                    {
                        tempSum += blackWhiteImage[counter2 +  counter4][counter1 + counter3] * gaussianArray[counter3 + 2][ counter4 + 2];
                    }
                }
                gaussianPixelArray[counter2][counter1] = tempSum / 273;
            }
        }
        
         createImageFromArray(gaussianPixelArray);
    }
    
    void Median()
    {

        int[][] medianPixelArray = new int[currentImage.getWidth()][currentImage.getHeight()];
        int[] tempArray = new int[9];
        
        //We will sort our pixel and its 8 neighbors. Midlle value will be new value of pixel. 
        for (int counter1 = 1; counter1 < currentImage.getHeight() - 1; counter1++)
        {
            for (int counter2 = 1; counter2 < currentImage.getWidth() - 1; counter2++)
            {
                int counter = 0;
                for (int counter3 = -1; counter3 < 2; counter3++)
                {
                    for (int counter4 = -1; counter4 < 2; counter4++)
                    {
                        tempArray[counter++] = blackWhiteImage[counter2 + counter4][counter1 + counter3];
                    }
                }
                Arrays.sort(tempArray);
                
                medianPixelArray[counter2][counter1] = tempArray[4];
            }
        }
        
        createImageFromArray(medianPixelArray);
    }
    
    void createImageFromArray(int[][] array)
    {
        BufferedImage tempImage = new BufferedImage(currentImage.getWidth(), currentImage.getHeight(), BufferedImage.TYPE_INT_RGB);
        
        //We create RGB values from array and create image with these datas.    
        for(int counter1 = 0; counter1 < currentImage.getWidth(); counter1++)
        {
            for(int counter2 = 0; counter2 < currentImage.getHeight(); counter2++)
            {
                tempImage.setRGB(counter1, counter2, new Color(array[counter1][counter2],array[counter1][counter2],array[counter1][counter2]).getRGB());
            }
        }
        
        currentImage = tempImage;
        setIconImage(currentImage);
    }
    
    
    void setIconImage(BufferedImage img)
    {
        //Resize viewable image
        int[] result = calculateImageSize();
     
        //Set label to Image
        label.setHorizontalAlignment(SwingConstants.CENTER);
        label.setVerticalAlignment(SwingConstants.CENTER);
        label.setIcon(new ImageIcon(new ImageIcon(img).getImage().getScaledInstance(result[0], result[1], img.SCALE_DEFAULT)));

    }
    
    int[] calculateImageSize()
    {
        int imageX = currentImage.getWidth();
        int imageY = currentImage.getHeight();
        
        int[] result = new int[2];
        
        int counter = 0;
        
        //Finding optimal sizes to view image
        //Always I divide 2. It is not best way to views, but I think it is easy way with easy process.  
        if(imageX <= imageY)
        {
            while(imageX > imagePanel.getWidth())
            {
                imageX = imageX/2;
                counter++;
            }
            if(counter != 0) imageY = imageY / (int)Math.pow(2, counter);
            
        }
        else
        {
            while(imageY > imagePanel.getHeight())
            {
                imageY = imageY/2;
                counter++;
            }
            if(counter != 0) imageX = imageX / (int)Math.pow(2, counter);           
        }
        
        result[0] = imageX;
        result[1] = imageY;
        
        return result;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Hello.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Hello.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Hello.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Hello.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Hello().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton blackWhite;
    private javax.swing.JButton gaussian;
    private java.awt.Label his_max;
    private java.awt.Label his_min;
    private javax.swing.JButton histogram;
    private javax.swing.JPanel histogramPanel;
    private javax.swing.JPanel imagePanel;
    private javax.swing.JLabel label;
    private javax.swing.JButton mean;
    private javax.swing.JButton median;
    private javax.swing.JButton negative;
    private javax.swing.JButton otsu;
    private javax.swing.JButton reset;
    private javax.swing.JButton save;
    private javax.swing.JButton saveHistogram;
    private javax.swing.JButton select;
    private javax.swing.JButton sepiaButton;
    private javax.swing.JButton stretch;
    // End of variables declaration//GEN-END:variables
}
